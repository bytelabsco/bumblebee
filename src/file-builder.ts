import fs from 'fs';
import path from 'path';
import { Namespacer } from "./core/utilities/namespacer";
import { cssVariableGroupDefinitionFormatter } from "./core/formatters/css-variable-group-defintion.formatter";
import { VariableTokenizer } from "./core/variable-tokenizer";
import { VariableGroupGenerator } from "./core/variable-group-generator";
import { UtilityVariableResolver } from "./core/utility-variable-resolver";
import { UtilityExpander } from "./core/utility-expander";
import { scssUtilityPlaceholderFormatter } from "./core/formatters/scss-utility-placeholder.formatter";
import { UtilityDefinition } from "./core/models/utility-definition";
import { scssUtilityByIncludeFormatter, ScssUtilityByIncludeFormatterOptions } from "./core/formatters/scss-utility-by-include.formatter";
import { NEW_LINE } from "./core/constants";
import { ThemeCollection, BreakpointCollection, VarEntry, NestedConfigCollection, UtilityEntry, NamespaceSettings } from './core/models';
import { collectionSize } from './core/utilities';
import { scssUtilityMixinsFormatter } from './core/formatters/scss-utility-mixins.formatter';
import { scssVariableMapFormatter } from './core/formatters/scss-variable-map.formatter';

import * as sass from 'sass';
import { scssVariablesFormatter } from './core/formatters/scss-variables.formatter';

export class FileBuilder {

    private _themes: ThemeCollection | undefined;
    private _breakpoints: BreakpointCollection | undefined;
    private _variables: NestedConfigCollection<VarEntry> | undefined;

    private _GENERATED_NOTICE = `/*** Auto-Generated by Bumblebee | ${new Date().toString()} ***/${NEW_LINE + NEW_LINE}`;

    public withNamespace(namespace: NamespaceSettings) {

        if(!namespace){
            throw new Error('namespace must be provided');
        }

        Namespacer.SetNamespace(namespace);        
    }

    public withThemes(themes: ThemeCollection) {
        
        if(!themes){
            throw new Error('themes must be provided');
        }

        this._themes = themes;
    }

    public withBreakpoints(breakpoints: BreakpointCollection) {

        if(!breakpoints){
            throw new Error('breakpoints must be provided');
        }

        this._breakpoints = breakpoints;
    }

    public withVars(vars: NestedConfigCollection<VarEntry>): FileBuilder {

        if(!vars){
            throw new Error('vars must be provided');
        }

        this._variables = vars;

        return this;
    }


    public build(utilities: NestedConfigCollection<UtilityEntry>, filePath: string) {

        let variableTokens: Map<string, VarEntry> | undefined;

        const tempPath = path.join(filePath, '_tmp');

        const scssPath = path.join(filePath, 'scss');
        const cssPath = path.join(filePath, 'css');

        let cssVariables: string = '';

        if(this._variables && collectionSize(this._variables) > 0){
            variableTokens = VariableTokenizer.execute({vars: this._variables});
            cssVariables = this.generateCssVariables(variableTokens);
        }
        
        if(variableTokens) {
            utilities = UtilityVariableResolver.execute({utilities: utilities, varTokens: variableTokens});
        }

        var utilityValues = UtilityExpander.execute({utilities: utilities});

        // SCSS Mixins
        var scssMixins = this.generateScssMixins(utilityValues);

        const mixinPath = path.join(scssPath, '_mixins.scss');
        this.writeFile(mixinPath, scssMixins);
        this.prepend(mixinPath, this._GENERATED_NOTICE);


        // SCSS Placeholders
        var scssPlaceholders = this.generateScssPlaceholders(utilityValues, 'mixins');

        const placehoderPath = path.join(scssPath, '_placeholders.scss');
        this.writeFile(placehoderPath, scssPlaceholders);
        this.prepend(placehoderPath, this._GENERATED_NOTICE);

        // CSS Utilities
        var scssUtilities = this.generateScssUtilities(utilityValues);

        var cssUtilitiesResult = sass.renderSync({
            data: `${scssMixins}${NEW_LINE}${cssVariables}${NEW_LINE}${scssUtilities}`
        });

        const utilitiesPath = path.join(cssPath, 'utilities.css');
        this.writeFile(utilitiesPath, cssUtilitiesResult.css.toString());
        this.prepend(utilitiesPath, this._GENERATED_NOTICE);

        if(this._variables && collectionSize(this._variables) > 0){
            // Write out scss variables last since they aren't used in any other processing
            const scssVariables = this.generateScssVariables(this._variables);
            
            const scssVariablesPath = path.join(scssPath, '_variables.scss');
            this.writeFile(scssVariablesPath, scssVariables);
            this.prepend(scssVariablesPath, this._GENERATED_NOTICE);
        }
        
    }

    private generateScssVariables(vars: NestedConfigCollection<VarEntry>) : string {

        let fileContent = `/** These variables are not referenced by other Bumblebee generated files **/${NEW_LINE}`;
        fileContent += `/** They are provided as a convenience for additional class generation by the user **/${NEW_LINE + NEW_LINE}`;

        fileContent += scssVariablesFormatter(vars);

        return fileContent;

    }

    private generateCssVariables(variableTokens: Map<string, VarEntry>): string {

        let fileContent = '';

        const variableGroups = VariableGroupGenerator.execute({varTokens: variableTokens, themes: this._themes});

        variableGroups.forEach(g => {
            fileContent += cssVariableGroupDefinitionFormatter(g);
        })

        return fileContent;

    }

    private generateScssMixins(utilityValues: Map<string, UtilityDefinition>): string {

        let fileContent = scssUtilityMixinsFormatter(utilityValues);
        
        return fileContent;
    }

    private generateScssPlaceholders(utilityValues: Map<string, UtilityDefinition>, mixins?: string): string{

        let fileContent = '';

        if(!!mixins) {
            fileContent += `@use './${mixins}';${NEW_LINE + NEW_LINE}`;
        }

        fileContent += scssUtilityPlaceholderFormatter({utilities: utilityValues, mixinNamespace: mixins});
        
        return fileContent;
    }

    private generateScssUtilities(utilityValues: Map<string, UtilityDefinition>, mixins?: string): string {

        let fileContent = '';

        if(!!mixins) {
            fileContent += `@use './${mixins}';${NEW_LINE + NEW_LINE}`;
        }
        
        const utilityOptions: ScssUtilityByIncludeFormatterOptions = {
            utilities: utilityValues,
            breakpoints: this._breakpoints,
            mixinNamespace: mixins
        };

        fileContent += scssUtilityByIncludeFormatter(utilityOptions);

        return fileContent;
    }

    private writeFile(file: string, content: string) {

        const filePath = path.dirname(file);

        if(!fs.existsSync(filePath)) {
            fs.mkdirSync(filePath, { recursive: true});
        }
    
        fs.closeSync(fs.openSync(file, 'w'));

        fs.writeFileSync(file, content);
    }

    private prepend(file: string, content: string) {

        const data = fs.readFileSync(file);
        const fd = fs.openSync(file, 'w+');
        const insert = Buffer.from(content);
        fs.writeSync(fd, insert, 0, insert.length, 0);
        fs.writeSync(fd, data, 0, data.length, insert.length);
        fs.closeSync(fd);
    }
}